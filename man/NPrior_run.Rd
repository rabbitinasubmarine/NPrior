% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Nprior_eval.R
\name{NPrior_run}
\alias{NPrior_run}
\title{Neuronized Priors for Bayesian Sparse Linear Regression}
\usage{

NPrior_run(X, y, N = 10000, BURN = 2000, prior = "SpSL-L",

sig = NULL, eta = NULL, alpha0 = NULL, alpha = NULL, w = NULL, 

sig_update = T, alpha0_update = T, method = "exact", 

prior_prop = NULL, s = 2, K = 10, B_size = NULL, a0 = 1, b0 = 1, prior_sig_type = 0, 

verbose = T)

}
\arguments{
\item{X}{The covariate n by p maxtix}

\item{y}{The response}

\item{N}{Total MCMC iterations after burn-in. The default is 10000}

\item{BURN}{Total burnin iterations. The default is 2000.}

\item{prior}{The type of priors; "SpSL-L": discrete spike and slab prior with a Laplace-like prior (T(t) = max{0,t}); "SpSL-C": discrete spike and slab prior with a Cauchy prior (T(t) = exp( 0.5*t^2  - 1.27*t + 0.29 )), if t>0 and 0, otherwise); "SpSL-G": discrete spike and slab prior with a Gaussian prior (T(t) = 1, if t>0 and 0,. otherwise);  "HS": horseshoe prior ; "BL": Bayesian LASSO. The default is "SpSL-L"}

\item{sig}{The value of sigma^2}

\item{eta}{The variance parameter of w. For "SpSL-L", "SpSL-C" and "SpSL-G", the default is 1. For "HS" and "BL", the default is p^-2.}

\item{alpha0}{The value of alpha0. For the continuous shrinkage priors ("HS" and "BL"), this option will be ignored and set to be alpha0 = 0.}

\item{alpha}{The initial value of alpha}

\item{w}{The initial value of w}

\item{sig_update}{T: update sigma^2; F: no update sigma^2. The default is T.}

\item{alpha0_update}{T: update alpha0; F: no update alpha0. The default is T. Fpr "HS" and "BL", this option will be ignored and set alpha0=0.}

\item{method}{For discrete SpSL, a method of updating alpha in MCMC; "exact": using a closed form of conditional posterior; "RWMH": using a random walk Metropolis Hasting algorithm to update alpha}

\item{prior_prop}{The value of prior proportion of non-zero parameters; then, alpha0 is set to be -Phi^{-1}(prior_prop). When alpha0 is specifeid, this option will be ignored. The default is NULL.}

\item{s}{The scale of proposal distribution in the random walk MH algorithm}

\item{K}{In a singe iteration, the number of updates for alpha in the random walk MH algorithm}

\item{B_size}{The size of block updates for w}

\item{a0}{The value of a0 in Bernoulli-beta prior. For continuous shrinkage priors, this option will be ignored.}


\item{b0}{The value of b0 in Bernoulli-beta prior. For continuous shrinkage priors, this option will be ignored}


\item{prior_sig_type}{The prior type regarding sigma^2; 1: w ~ N(0, eta*sigma^2); 0: w ~ N(0, eta). The default is 0.}

\item{verbose}{verbose. The default is T.}
}
\value{
\item{ThetaSamples}{the MCMC samples of coefficients}
\item{ThetaHat}{the posterior mean of coefficients}
\item{SigSamples}{the MCMC samples of sigma^2}
\item{Alpha0Samples}{the MCMC samples of alpha0}
\item{AlphaSamples}{the MCMC samples of alpha}
\item{WSamples}{the MCMC samples of w}
\item{POST}{the log-posterior density values from the MCMC}
\item{setting}{The specified settings}

}
\description{
We develop a unified and flexible Bayesian shrinkage procedure called "Neuronized Priors". }
\examples{
library(MASS)
data(Boston)
str(Boston)
attach(Boston)
X = cbind(crim,indus,nox,rm,age,dis,tax,ptratio,black,lstat)
X = scale(X)
y = medv
y = y-mean(y)
n = nrow(X)
p = ncol(X)
#fit = library(MASS)
data(Boston)
str(Boston)
attach(Boston)
X = cbind(crim,indus,nox,rm,age,dis,tax,ptratio,black,lstat)
X = scale(X)
y = medv
y = y-mean(y)
n = nrow(X)
p = ncol(X)
### the default setting (SpSL-L)
#fit = NPrior_run(X, y)  
#boxplot(t(fit$THETA))

### implement a horseshoe prior
#fit_HS1 = NPrior_run(X, y, prior = "HS") 

### implement a horseshoe prior with eta = p^-3
#fit_HS = NPrior_run(X, y, prior = "HS", eta = p^-3)

### implement a discrete spike-and-slab prior 
### with a Cauchy slab prior and a Beta(1,p) on the sparsity parameter.
#fit_c = NPrior_run(X, y, prior = "SpSL-C", a0 = 1, b0 = p) 

### implement a discrete spike-and-slab prior 
### with a Gaussian slab prior with a fixed alpha0 = 3.
#fit_g0 = NPrior_run(X, y, prior = "SpSL-L", alpha0_update = F, alpha0 = 3) 
}


